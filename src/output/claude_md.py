"""CLAUDE.md generator — machine-readable project briefing for Claude Code."""

import logging
import re
from datetime import datetime, date, timezone
from pathlib import Path
from typing import Optional

from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession

from src.config import get_settings
from src.storage.models import (
    Person,
    Project,
    ProjectPeople,
    Sprint,
    Task,
    UserPreference,
)

logger = logging.getLogger(__name__)

DOCS_BASE = Path(__file__).resolve().parent.parent.parent / "docs"


def _read_doc_file(path: Path) -> str:
    """Read a docs file and return stripped content, or empty string if missing."""
    if not path.exists():
        logger.debug("Doc file not found: %s", path)
        return ""
    return path.read_text().strip()


def _get_pitfall_count(pitfalls_path: Path) -> tuple[int, str]:
    """Parse P-NNN headers from pitfalls file, return (count, last_id).

    Returns (0, "P-000") if file is missing or has no entries.
    """
    content = _read_doc_file(pitfalls_path)
    if not content:
        return (0, "P-000")
    ids = re.findall(r"## (P-\d+)", content)
    if not ids:
        return (0, "P-000")
    return (len(ids), ids[-1])


def _parse_recent_decisions(content: str, limit: int = 10) -> str:
    """Extract the last N decision entries from DECISIONS.md content."""
    if not content:
        return ""
    entries = re.split(r"(?=^## \d{4}-\d{2}-\d{2}:)", content, flags=re.MULTILINE)
    entries = [e.strip() for e in entries if re.match(r"^## \d{4}-\d{2}-\d{2}:", e)]
    if not entries:
        return ""
    recent = entries[-limit:]
    return "\n\n".join(recent)


async def generate_claude_md(
    session: AsyncSession,
    project_slug: Optional[str] = None,
    output_path: Optional[Path] = None,
    generate_docs: bool = False,
    docs_base: Optional[Path] = None,
) -> str:
    """Generate CLAUDE.md for a project (or the Focus project itself).

    Args:
        session: Async DB session.
        project_slug: Target project slug, or None for Focus itself.
        output_path: Where to write CLAUDE.md. Defaults to cwd/CLAUDE.md.
        generate_docs: If True and project_slug is set, also generate project docs.
        docs_base: Base directory for docs files. Defaults to repo docs/.

    Returns the generated content as a string and writes it to disk.
    """
    settings = get_settings()
    base = docs_base or DOCS_BASE

    # Get the target project
    if project_slug:
        result = await session.execute(
            select(Project).where(Project.slug == project_slug)
        )
        project = result.scalar_one_or_none()
        if not project:
            logger.warning("Project %s not found for CLAUDE.md generation", project_slug)
            return ""
    else:
        project = None

    if generate_docs and project:
        await generate_project_docs(session, project_slug, base)

    now = datetime.now(timezone.utc)

    sections = []

    # Header
    project_name = project.name if project else "Focus"
    sections.append(f"# CLAUDE.md — {project_name}")
    sections.append("")
    sections.append(f"> Auto-generated by Focus. Last updated: {now.strftime('%Y-%m-%dT%H:%M:%SZ')}")
    if project:
        sections.append(f"> Source: vault/Projects/{project.name.replace(' ', '-')}/")
    sections.append("")

    # Project section
    _add_project_section(sections, project)

    # Architecture section
    _add_architecture_section(sections, base)

    # Current Sprint (tasks in progress + waiting)
    await _add_current_sprint_section(session, sections, project)

    # Blockers
    await _add_blockers_section(session, sections, project)

    # Active Sprint (time-bounded)
    await _add_active_sprint_section(session, sections, now)

    # Conventions
    await _add_conventions_section(session, sections, base)

    # Testing mandate
    _add_testing_section(sections, base)

    # Pitfalls (read from docs/PITFALLS.md)
    _add_pitfalls_section(sections, base)

    # Recent Decisions
    _add_recent_decisions_section(sections, base)

    # People
    await _add_people_section(session, sections, project)

    # Deep Context references
    _add_deep_context_section(sections, project, base)

    content = "\n".join(sections) + "\n"

    # Write to disk
    if output_path is None:
        output_path = Path.cwd() / "CLAUDE.md"
    output_path = Path(output_path)
    output_path.write_text(content)
    logger.info("Generated CLAUDE.md at %s", output_path)

    return content


def _add_project_section(
    sections: list[str],
    project: Optional[Project],
) -> None:
    """Add project description section."""
    sections.append("## Project")
    sections.append("")
    if project and project.description:
        sections.append(project.description)
    else:
        sections.append(
            "Local-first AI-powered PKM system. Ingests email/texts/docs, extracts "
            "structured data via tiered LLM pipeline, generates self-organizing "
            "Obsidian vault. Python 3.11 + FastAPI + PostgreSQL + Chroma + Ollama."
        )
    sections.append("")


def _add_architecture_section(
    sections: list[str],
    docs_base: Path,
) -> None:
    """Add architecture section from docs/ARCHITECTURE.md."""
    content = _read_doc_file(docs_base / "ARCHITECTURE.md")
    if content:
        sections.append(content)
        sections.append("")


async def _add_current_sprint_section(
    session: AsyncSession,
    sections: list[str],
    project: Optional[Project],
) -> None:
    """Add current work items (in_progress + waiting + up_next)."""
    sections.append("## Current Sprint")
    sections.append("")

    query = select(Task).where(Task.status == "in_progress")
    if project:
        query = query.where(Task.project_id == project.id)
    result = await session.execute(query.order_by(Task.created_at.asc()))
    in_progress = result.scalars().all()

    if in_progress:
        sections.append("IN PROGRESS:")
        for task in in_progress:
            sections.append(f"- {task.title}")
    else:
        sections.append("IN PROGRESS: (none)")

    sections.append("")

    query = select(Task).where(Task.status == "waiting")
    if project:
        query = query.where(Task.project_id == project.id)
    result = await session.execute(query)
    waiting = result.scalars().all()

    if waiting:
        sections.append("WAITING:")
        for task in waiting:
            info = ""
            if task.waiting_since:
                days = (datetime.now(timezone.utc) - task.waiting_since).days
                info = f" ({days} days)"
            sections.append(f"- {task.title}{info}")

    sections.append("")

    query = select(Task).where(Task.status == "backlog")
    if project:
        query = query.where(Task.project_id == project.id)
    result = await session.execute(query.order_by(Task.created_at.asc()).limit(5))
    backlog = result.scalars().all()

    if backlog:
        sections.append("UP NEXT:")
        for task in backlog:
            sections.append(f"- {task.title}")

    sections.append("")


async def _add_blockers_section(
    session: AsyncSession,
    sections: list[str],
    project: Optional[Project],
) -> None:
    """Add blockers section."""
    query = select(Task).where(Task.status == "waiting")
    if project:
        query = query.where(Task.project_id == project.id)
    result = await session.execute(query)
    waiting = result.scalars().all()

    sections.append("## Blockers")
    sections.append("")
    if waiting:
        for task in waiting:
            info = ""
            if task.waiting_since:
                days = (datetime.now(timezone.utc) - task.waiting_since).days
                info = f" — {days} days"
            sections.append(f"- {task.title}{info}")
    else:
        sections.append("No current blockers.")
    sections.append("")


async def _add_active_sprint_section(
    session: AsyncSession,
    sections: list[str],
    now: datetime,
) -> None:
    """Add active time-bounded sprint info."""
    result = await session.execute(
        select(Sprint).where(
            Sprint.is_active.is_(True),
            Sprint.starts_at <= now,
            Sprint.ends_at >= now,
        )
    )
    sprints = result.scalars().all()

    sections.append("## Active Sprint")
    sections.append("")
    if sprints:
        for sprint in sprints:
            days_left = (sprint.ends_at.date() - now.date()).days
            sections.append(f"{sprint.name} until {sprint.ends_at.strftime('%b %d')} — {days_left} days left")
            if sprint.description:
                sections.append(sprint.description)
    else:
        sections.append("NONE")
    sections.append("")


async def _add_conventions_section(
    session: AsyncSession,
    sections: list[str],
    docs_base: Path,
) -> None:
    """Add coding conventions — DB override takes precedence over docs file."""
    sections.append("## Conventions")
    sections.append("")

    # Try to load from user preferences first
    result = await session.execute(
        select(UserPreference).where(UserPreference.key == "coding_conventions")
    )
    pref = result.scalar_one_or_none()

    if pref and pref.value:
        conventions = pref.value.get("rules", [])
        for rule in conventions:
            sections.append(f"- {rule}")
    else:
        # Read from docs file
        content = _read_doc_file(docs_base / "CONVENTIONS.md")
        if content:
            # Strip the "# Conventions" header — we already added it
            lines = content.split("\n")
            body_lines = [l for l in lines if not l.startswith("# ")]
            sections.append("\n".join(body_lines).strip())
        else:
            sections.append("_(No conventions configured.)_")
    sections.append("")


def _add_testing_section(sections: list[str], docs_base: Path) -> None:
    """Add mandatory testing rules from docs/TESTING.md."""
    content = _read_doc_file(docs_base / "TESTING.md")
    if content:
        sections.append(content)
        sections.append("")
    else:
        sections.append("## Testing (MANDATORY)")
        sections.append("")
        sections.append("_(Testing rules not found. Create docs/TESTING.md.)_")
        sections.append("")


def _add_pitfalls_section(sections: list[str], docs_base: Path) -> None:
    """Inject docs/PITFALLS.md contents so Claude always sees past mistakes."""
    content = _read_doc_file(docs_base / "PITFALLS.md")
    if content:
        sections.append(content)
        sections.append("")


def _add_recent_decisions_section(
    sections: list[str],
    docs_base: Path,
    limit: int = 10,
) -> None:
    """Add recent decisions from docs/DECISIONS.md."""
    sections.append("## Recent Decisions")
    sections.append("")
    content = _read_doc_file(docs_base / "DECISIONS.md")
    recent = _parse_recent_decisions(content, limit=limit)
    if recent:
        sections.append(recent)
    else:
        sections.append("_(Decisions will appear here as they are tracked.)_")
    sections.append("")


def _add_deep_context_section(
    sections: list[str],
    project: Optional[Project],
    docs_base: Path,
) -> None:
    """Add deep context references."""
    sections.append("## Deep Context (read these files if you need more)")
    sections.append("")
    if project:
        proj_path = f"vault/Projects/{project.name.replace(' ', '-')}"
        sections.append(f"- Full task backlog: {proj_path}/KANBAN.md")
        sections.append(f"- All decisions: {proj_path}/DECISIONS.md")
        sections.append(f"- Project history: {proj_path}/TIMELINE.md")
        sections.append(f"- Email threads: {proj_path}/EMAILS.md")
    sections.append("- User preferences: vault/Me/Preferences.md")
    sections.append("- User commitments: vault/Me/Commitments.md")


async def _add_people_section(
    session: AsyncSession,
    sections: list[str],
    project: Optional[Project],
) -> None:
    """Add people context section."""
    sections.append("## People")
    sections.append("")

    if project:
        result = await session.execute(
            select(Person, ProjectPeople.role)
            .join(ProjectPeople, ProjectPeople.person_id == Person.id)
            .where(ProjectPeople.project_id == project.id)
        )
        people = result.all()

        if people:
            for person, role in people:
                role_label = f" ({role})" if role else ""
                sections.append(f"- **{person.name}**{role_label}")
                if person.notes:
                    sections.append(f"  {person.notes[:100]}")
        else:
            sections.append("_(No people linked to this project.)_")
    else:
        sections.append("_(Configure people by running `focus sync` to ingest emails.)_")

    sections.append("")


async def generate_project_docs(
    session: AsyncSession,
    project_slug: str,
    docs_base: Optional[Path] = None,
) -> Path:
    """Generate documentation scaffold for a project.

    Creates docs/projects/<slug>/ with template files.
    Only creates files that don't exist (never overwrites).

    Returns the project docs directory path.
    """
    base = docs_base or DOCS_BASE
    project_dir = base / "projects" / project_slug
    project_dir.mkdir(parents=True, exist_ok=True)

    templates = {
        "ARCHITECTURE.md": (
            f"# Architecture — {project_slug}\n\n"
            "Describe the project structure here.\n"
        ),
        "DECISIONS.md": (
            f"# Decisions — {project_slug}\n\n"
            "Chronological log of design decisions.\n\n"
            "<!-- Add new decisions at the bottom. Format:\n"
            "## YYYY-MM-DD: Decision Title\n"
            "**Context**: Why this came up\n"
            "**Decision**: What was decided\n"
            "**Rationale**: Why\n"
            "-->\n"
        ),
        "DOMAIN.md": (
            f"# Domain — {project_slug}\n\n"
            "Key domain concepts, terminology, and business rules.\n"
        ),
    }

    for filename, content in templates.items():
        filepath = project_dir / filename
        if not filepath.exists():
            filepath.write_text(content)
            logger.info("Created project doc: %s", filepath)

    return project_dir
