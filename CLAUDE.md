# CLAUDE.md — Focus

> Auto-generated by Focus. Last updated: 2026-02-11T01:56:33Z

## Project

Local-first AI-powered PKM system. Ingests email/texts/docs, extracts structured data via tiered LLM pipeline, generates self-organizing Obsidian vault. Python 3.11 + FastAPI + PostgreSQL + Chroma + Ollama.

## Architecture

```
src/
├── ingestion/      # Gmail, Drive connectors
│   ├── gmail.py    # OAuth + incremental sync via historyId
│   └── accounts.py # Multi-account management
├── processing/     # Tiered AI pipeline
│   ├── classifier.py   # Ollama + Qwen3 4B (local, $0)
│   ├── extractor.py    # Claude Haiku (tasks, commitments, people)
│   ├── regex_parser.py # Automated email parsing ($0)
│   └── resolver.py     # Entity resolution + project linking
├── storage/        # Data layer
│   ├── db.py       # PostgreSQL via SQLAlchemy (async)
│   ├── models.py   # ORM models
│   └── raw.py      # Raw interaction archive
├── output/         # Markdown generation
│   ├── vault.py    # Obsidian vault generator
│   ├── kanban.py   # Per-project kanban boards
│   ├── daily.py    # Daily notes
│   ├── drafts.py   # Email draft suggestions
│   └── claude_md.py # This file's generator
├── api/            # FastAPI REST endpoints
├── cli/            # Typer CLI (focus command)
└── daemon.py       # Background sync daemon
```

Key patterns: async throughout, SQLAlchemy 2.0 style, Pydantic models
for all data, raw interactions stored permanently for reprocessing.

## Current Sprint

IN PROGRESS: (none)


UP NEXT:
- Confirm cancellation of all future orders for Nathan Simon's account
- Cancel future orders for nathanaaronsimon@gmail.com (topical hair collation)
- Confirm cancellation to Nathan Simon

## Blockers

No current blockers.

## Active Sprint

NONE

## Conventions

- Type hints on all functions
- Explicit over implicit
- Functions under 50 lines
- Docstrings on public functions (Google style)
- snake_case everywhere
- Use `rich` for CLI output
- Use logging, not print()
- Prefer composition over inheritance
- Raw SQL only in migrations; use SQLAlchemy ORM elsewhere

## Testing (MANDATORY)

Every code change MUST include tests. No exceptions. Run `pytest tests/ -x -q` after writing them.

- **Bug fixes**: Write a regression test that fails without the fix and passes with it.
- **New functions**: Test happy path, edge cases (empty input, None, missing keys), and error paths.
- **Refactors**: Ensure existing tests still pass; add tests for any new branches.
- **Integration points** (DB, APIs, external services): Mock them. Tests must run without postgres/ollama/anthropic.
- **Async code**: Test concurrency-sensitive paths (e.g., multiple coroutines sharing state).

Structure:
- File per module: `tests/test_<module_name>.py`
- Use `conftest.py` fixtures: `make_email()`, `make_project()`, `make_task()`
- Mock external deps with `unittest.mock` / `AsyncMock`
- Aim for: every public function has at least one test, every branch has coverage

If you can verify a behavior by writing a test, write the test. Don't just fix and hope.

## Post-Mortem (MANDATORY)

When you cause a bug, introduce a regression, or discover a mistake in your own work:
1. Fix it and write a regression test
2. **Immediately** add a new entry to `docs/PITFALLS.md` (P-NNN format) explaining what went wrong and how to avoid it
3. Do NOT wait for `focus sync` — edit the file directly as part of the fix

This is not optional. The pitfalls file is your institutional memory. Every mistake not recorded is a mistake repeated.

# Pitfalls

Hard-won lessons from past bugs. Read before changing code.

## P-001: Shared async session + concurrent coroutines = "Session is already flushing"

SQLAlchemy AsyncSession is NOT safe for concurrent use from multiple coroutines.
If you `asyncio.gather` N tasks that all call `session.flush()` on the same session,
one flush will be mid-flight when another starts, causing the error.

**Fix**: Give each concurrent coroutine its own session via `get_session()`.

## P-002: Inner sessions can't see uncommitted data from outer sessions

If session A flushes rows (visible within A) and then you open session B in a
separate transaction, B cannot see A's rows until A commits.

This silently breaks pipelines where step 1 inserts data and step 2 processes
it in a new session. Everything looks fine — no exceptions — but the inner
session just gets None back and silently skips the work.

**Fix**: Commit the outer session before spawning inner sessions that need to
read its data. Always log or surface when inner lookups return None unexpectedly.

## P-003: Don't gate processing on "new items fetched"

`if emails_fetched > 0: process()` means that if processing fails mid-run,
re-running sync will skip processing entirely because the emails are already
fetched. Unprocessed items from prior runs are silently abandoned.

**Fix**: Always attempt processing. The query already filters for unprocessed
items (`classification IS NULL`), so it's a no-op when everything is done.

## P-004: Async SQLAlchemy cannot lazy-load relationships

Accessing `email.account` or `commitment.person` in async code triggers a
synchronous DB call that fails with `MissingGreenlet`. This only manifests when
the data actually exists (e.g., after the first successful processing run).

**Fix**: Use `selectinload()` in every query that touches objects whose
relationships will be accessed. Audit all `.attribute` accesses on ORM objects
in sync helper functions called from async code.

## P-005: Always surface error counts in CLI output

If your summary dict has an `errors` field but the CLI doesn't print it,
failures are completely invisible to the user. They see "Classified: 0" and
assume nothing was there, when actually everything errored out.

**Fix**: Always print error counts when > 0. Never silently swallow failure stats.

## P-006: Resolver gate didn't check commitments

The pipeline's resolver gate condition only checked for `tasks`, `people_mentioned`,
and `project_links` — but NOT `commitments`. Emails with commitments but no tasks
or people would skip resolution entirely, silently producing 0 commitment rows.

**Fix**: Add `extraction.get("commitments")` to the gate condition. Always check
every entity type the resolver can create.

## P-007: API sync endpoint gated processing on emails_fetched (P-003 repeat)

The `/sync` POST endpoint had `if request.process and sync_result["emails_fetched"] > 0`,
repeating the exact same bug as P-003 in the API layer. If sync fetched 0 new emails
but there were unprocessed emails from prior runs, processing was skipped.

**Fix**: Only gate on `request.process`, not on `emails_fetched > 0`.

## Recent Decisions

_(Decisions will appear here as they are tracked.)_

## People

_(Configure people by running `focus sync` to ingest emails.)_

## Deep Context (read these files if you need more)

- User preferences: vault/Me/Preferences.md
- User commitments: vault/Me/Commitments.md
